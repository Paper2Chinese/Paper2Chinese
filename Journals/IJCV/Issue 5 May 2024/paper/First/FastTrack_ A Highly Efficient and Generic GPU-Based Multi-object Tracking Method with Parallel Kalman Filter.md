# 题目：[FastTrack: A Highly Efficient and Generic GPU-Based Multi-object Tracking Method with Parallel Kalman Filter](https://link.springer.com/article/10.1007/s11263-023-01933-4)  
## 基于并行卡尔曼滤波器的高效通用GPU多目标跟踪方法
**作者：Chongwei Liu, Haojie Li & Zhihui Wang** 

# 摘要
基于均匀假设的卡尔曼滤波器一直是跟踪器中关键的运动估计模块。然而，当应用于大规模目标跟踪场景时，它在非均匀运动建模和计算效率方面存在局限性。为了解决这些问题，我们提出了一种新颖的并行卡尔曼滤波器（PKF），它简化了传统的状态变量，以减少计算负载并实现有效的非均匀建模。在PKF中，我们提出了一种非均匀公式，通过将时间间隔Δt从常量转换为与位移相关的变量来模拟非均匀运动，并将减速策略纳入公式的控制输入模型中，以解决多目标跟踪（MOT）中的逃逸问题；我们还提出了一种创新的并行计算方法，该方法将PKF的计算图从矩阵转换为二次形式，显著减少了计算负载，并通过对CUDA的不同轨迹进行并行计算，从而使PKF的时间消耗与输入轨迹规模无关，即O(1)。基于PKF，我们介绍了Fast，这是第一个完全基于GPU的跟踪器范式，它显著提高了大规模目标跟踪场景中的跟踪效率；以及FastTrack，由Fast和通用检测器组成的MOT系统，提供了高效率和通用性。在FastTrack中，Fast在一次迭代中只需要带有分数和类别ID的边界框进行单一关联，并引入了创新的基于GPU的跟踪模块，如高效的GPU 2D数组数据结构用于轨迹管理，一种新的在CUDA中实现的用于自动关联优先级确定的成本矩阵，一种称为HIoU的新关联度量，以及首次在CUDA中实现的拍卖算法用于解决非对称分配问题。实验表明，PKF在GTX 1080Ti上的平均每次迭代时间仅为0.2毫秒；Fast在GTX 1080Ti上能够实现250FPS的实时效率，在Jetson AGX Xavier上甚至达到42FPS，超越了传统的基于CPU的跟踪器。同时，FastTrack在四个公共基准测试中展示了最先进的性能，特别是在MOT20的大规模跟踪场景中达到了最高速度。

# 关键词
多目标跟踪 · 基于GPU的跟踪器 · 并行卡尔曼滤波器 · 实时效率

# 引言
多目标跟踪（MOT）主要遵循检测后跟踪的范式。一个MOT系统通常包括一个通用检测器和一个基于运动的通用跟踪器。尽管卡尔曼滤波器（KF）是许多最先进跟踪器的关键运动估计模块，但它在应用于MOT时在运动建模和计算效率方面存在局限性。关于运动建模，KF假设物体运动是均匀的，这不适合一般跟踪场景中的各种运动模式，如图1所示。虽然扩展KF（EKF）和无迹KF（UKF）被引入以处理通过泰勒近似的非均匀运动，但它们计算复杂，且无法估计任意非均匀运动，例如舞台上舞者的高随机运动。此外，KF对噪声敏感，导致逃逸问题。当物体丢失时，KF在没有观测信息监督的情况下持续预测其边界框，导致其沿当前速度方向迅速逃逸，使得难以重新追踪。例如，在图1中，当物体在某个圆形点丢失时，KF预测的边界框沿速度方向迅速逃逸。关于计算效率，每个轨迹用一个独立的KF表示，所有KF顺序更新。这个过程导致所有KF的时间消耗与输入轨迹计数成线性增长，这种计算开销对应于时间复杂度O(n)，其中n表示轨迹总数。这种大量的资源分配削弱了跟踪效率，尤其是在大规模目标跟踪场景中。例如，基于CPU的跟踪算法OCSORT虽然改进了KF以获得最先进的性能，但在计算效率方面却不足。因此，当输入轨迹数从KITTI中的6个增加到MOT20中的139个时，OCSORT的时间消耗几乎增加了30倍，如图2所示。因此，一个优秀的跟踪器必须在跟踪精度和计算效率之间取得平衡。为了解决这些问题，我们引入了一种新颖的并行卡尔曼滤波器（PKF），它模拟非均匀运动，同时实现了O(1)的时间复杂度。在建模中，为KF选择一套合适的状态变量至关重要。因此，我们修改了传统的八元组状态变量，并用更简化的四元组状态变量集替换它们，重点关注对象中心的2D坐标及其相应的速度。这种简化减少了计算负载，并更适当地符合对象的相邻帧近似假设，从而有效模拟非均匀运动。


<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/f2d6553da9d246b9985290c5f0909ac9.png" width="800" />
</div>

# 3 数值统计
为了解决卡尔曼滤波器（KF）的建模问题，我们对一般跟踪场景进行了统计分析，以阐明物体运动的特点并总结先验知识。为了方便起见，我们选择了四个基准测试进行研究，分别是MOT17、MOT20、KITTI和DanceTrack，相应的信息见表1。MOT17和MOT20包含行人场景。MOT17与其他数据集相比，包含的视频和场景数量相对较少，而MOT20则增加了行人的密度并强调了它们之间的遮挡。MOT17和MOT20中的行人运动相当规律（低速且几乎均匀），并且它们保持可区分的外观。DanceTrack包括大量舞台场景。这些舞台上相似外观的舞者以混乱的方式移动，它们的运动与帧之间有显著差异，对模拟非均匀运动构成了相当大的挑战。KITTI是首批针对交通场景的大规模MOT数据集之一，专注于跟踪高速汽车和行人。在本节中，我们对上述四个基准数据集的真值进行了统计分析，包括MOT17、MOT20、KITTI和DanceTrack的训练集，以及DanceTrack的验证集。

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/c7c9674d612442898de4ba05ea3ddb00.png" width="800" />
</div>


## 3.1 轨迹重叠
如图3所示，我们计算了相邻帧中同一轨迹的IoU（交并比）。我们发现，对于低速物体（主要在MOT17/20和DanceTrack中），大多数IoU分布在0.7到1之间，表明即使没有估计，低速物体也可以很容易地在帧之间关联。对于高速物体（KITTI中的汽车或行人），KF的均匀运动建模对于它们的跟踪至关重要，因为它们主要表现出近乎线性的运动，如图1所示。在不知道物体的运动模式的情况下，模拟非均匀运动同时保持KF状态转移公式的简单性是具有挑战性的。然而，基于上述IoU统计数据，我们可以通过确定物体是否以低速运动来抑制KF的预测位移，从而实现非均匀运动建模。因此，从轨迹重叠中得出的先验是，与高速物体相比，低速物体在相邻帧中展现出更密集的IoU分布和高分的重叠。这表明在跟踪低速物体时，由于当前状态与观测状态重叠的可能性很高，KF不需要进行积极的态估计。相反，为了跟踪高速物体，KF需要进行积极的态估计以增加与观测的重叠概率。

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/e35337925e484a63a53a7799a4cb6f15.png" width="800" />
</div>


## 3.2 高度和宽度比率
如图4所示，我们计算了相邻帧中同一轨迹的高度和宽度比率。计算公式如下：

$$R = \min(x_ {cur}, x_ {next}) / \max(x_ {cur}, x_ {next})$$

其中R表示高度/宽度比率，x_ cur/x_ next分别表示当前帧和下一帧中同一轨迹的高度/宽度。显然，与DanceTrack中的舞者相比，MOT17/20和KITTI中的行人和汽车展现出更强的高度不变性（比率分布在0.7到1之间）而不是宽度不变性（比率分布在1到0.4之间）。这意味着我们可以通过在跟踪器设计中引入高度不变性先验来提高跟踪器的准确性。因此，从高度和宽度比率中得出的先验是，行人和汽车在相邻帧之间展现出强大的高度不变性，表明当两辆车或行人的高度比很小（例如，小于0.7）时，这两个物体很可能不属于同一轨迹。

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/edc7406530da4a678ab21e626e1ccc4b.png" width="800" />
</div>



# 4 提出的方法

## 4.1 平行卡尔曼滤波器（Parallel Kalman Filter, PKF）
### 建模
如第2.2节讨论的限制中所述，我们移除了 $\gamma$ 和 $h$ 变量，因此PKF将状态 $x$ 定义为四元组，即 $x = [u, v, \dot{u}, \dot{v}]^{\top}$，其中 $(u, v)$ 是物体中心的2D坐标，另外两个变量 $\dot{u}$ 和 $\dot{v}$ 是相应的速度。因此，过程噪声 $Q$、观测噪声 $R$ 和观测模型 $H$ 被重新定义为：

$$Q_ t = \text{diag}(\phi h^2, \phi h^2, \psi h^2, \psi h^2)$$
$$R_ t = \text{diag}(\phi h^2, \phi h^2)$$
$$H_ t = \begin{bmatrix} I_ {2 \times 2} & \mathbf{0}_ {2 \times 2} \\ \mathbf{0}_ {2 \times 2} & I_ {2 \times 2} \end{bmatrix}$$

其中权重 $\phi$ 和 $\psi$ 分别是 $(1/20)^2$ 和 $(1/80)^2$。简化的状态变量允许更有效地建模非均匀运动，并减少计算复杂性。如第3.1节所述，为了模拟非均匀运动，我们从基本运动方程 $V = S/T$ 开始，并通过将 $\Delta t$ 从常数转换为与位移 $s$ 相关的自适应变量来模拟非均匀运动，如方程9所示。基于轨迹重叠的先验，我们引入了 $\Delta t$ 阈值因子 $\xi$ 到 $\Delta t$ 中，以区分高速物体和低速物体，目的是仅抑制低速物体的估计位移。对于 $\dot{u}$ 和 $\dot{v}$ 的 $\Delta t$ 定义如下：

$$\Delta t_ {\dot{u} t-1} = \min(\xi, \frac{1}{|\dot{u}_ {t-1}|}) s_ {u t-1}, \quad \Delta t_ {\dot{v} t-1} = \min(\xi, \frac{1}{|\dot{v}_ {t-1}|}) s_ {v t-1}$$

其中，当速度的绝对值小于 $\frac{1}{\xi}$ 并且位移 $s$ 表示为：

$$s_ {u t-1} = |u_ {t-1} - u_ {t-2}|, \quad s_ {v t-1} = |v_ {t-1} - v_ {t-2}|$$

在实践中，通常设置 $s$ 为平滑的，以通过线性平滑权重 $\omega$ 减少噪声：

$$s_ {u t-1} = \omega |u_ {t-1} - u_ {t-2}| + (1 - \omega) s'_ {u t-2}, \quad s_ {v t-1} = \omega |v_ {t-1} - v_ {t-2}| + (1 - \omega) s'_ {v t-2}$$

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/3073da5841c044b19e9101849d9eece9.png" width="800" />
</div>


为了解决逃逸问题，我们在方程1a中恢复控制模型以实现减速策略。如第2.2节讨论的，当跟踪的物体丢失时，KF只执行预测阶段，导致噪声不断放大，如图6所示。因此我们通过丢失程度逐渐减少当前速度以抑制累积的噪声。减速比率 $r$ 定义为：

$$r = \frac{f_ id - f_ {end} - 1}{\tau}$$

其中 $f_ id$ 是当前帧号，$f_ {end}$ 是轨迹的结束帧 $EndFrame$ 属性；$\tau$ 是移除丢失时间过长的轨迹的最大丢失阈值，默认设置为30。当 $r$ 为0时，轨迹被跟踪并且减速一次；一旦轨迹丢失 $(f_ id - f_ {end} - 1 > 0)$，减速策略可以及早停止物体，增加重新追踪的概率。因此，非均匀公式中的四个变量表示为：

$$u_ {t|t-1} = u_ {t-1} + \dot{u}_ {t-1} \Delta t_ {\dot{u} t-1} (1 - \frac{r}{2}), \quad v_ {t|t-1} = v_ {t-1} + \dot{v}_ {t-1} \Delta t_ {\dot{v} t-1} (1 - \frac{r}{2}),$$

$$\dot{u}_ {t|t-1} = \dot{u}_ {t-1} (1 - r), \quad \dot{v}_ {t|t-1} = \dot{v}_ {t-1} (1 - r)$$

### 计算
为了达到O(1)的时间复杂度，我们利用简化的状态变量和非均匀公式的严格矩阵表示。在这种情况下，我们引入了一种创新的并行计算方法。该方法将PKF的计算图从矩阵转换为二次形可以很容易地通过CUDA在不同轨迹之间并行实现。例如，PKF的协方差矩阵 $P$ 表示为：

$$P = \begin{bmatrix} p_ 1 & p_ 7 & p_ 2 & p_ 8 \\ p_ 5 & p_ 3 & p_ 6 & p_ 4 \end{bmatrix}$$

其中没有变量的位置在任何时间步骤中都有一个值为0，因此我们可以通过消除这些0值位置及其相关的计算来减少存储和计算中的计算负载。因此，在存储中，我们可以定义协方差向量 $p$ 来等效表示矩阵 $P$，即 $p = [p_ 1, p_ 2, p_ 3, p_ 4, p_ 5, p_ 6, p_ 7, p_ 8]$。我们还定义了PKF计算中需要涉及的其他向量，它们是状态向量 $\hat{x} = [u, v, \dot{u}, \dot{v}]$，观测向量 $\hat{z} = [\bar{u}, \bar{v}, \bar{w}, \bar{h}]$，和属性向量 $o = [w, h, f_ {end}, s'_ u, s'_ v, u', v']$ 其中 $f_ {end}$ 是轨迹的结束帧属性；$s'_ u, s'_ v, u', v'$ 分别是先前的位移和坐标。算法1和算法2分别指示了PKF预测阶段和更新阶段的计算过程。在算法2中，$s_ 1$ 和 $s_ 2$ 表示矩阵 $S$ 主对角线上的元素，即 $S = \text{diag}(s_ 1, s_ 2)$。$k_ 1, k_ 2, k_ 3,$ 和 $k_ 4$ 表示卡尔曼增益中有价值的数字，即

$$K = \begin{bmatrix} k_ 1 & k_ 2 \\ k_ 3 & k_ 4 \end{bmatrix}$$

$r_ u, r_ v, r_ w, r_ h$ 是观测和估计之间的 $u, v, w, h$ 的残差。对于初始化，$\hat{x}$ 中的 $u, v$ 和 $o$ 中的 $w, h$ 被设置为输入检测结果中的相应值；$\hat{x}$ 中的 $\dot{u}, \dot{v}$ 和 $o$ 中的 $s'_ u, s'_ v$ 被设置为0；$o$ 中的 $u', v'$ 被设置为 $u$ 和 $v$ 的值；$f_ {end}$ 被设置为当前帧ID $f_ id$。向量 $p$ 被初始化为 [4$\phi h^2$, 4$\phi h^2$, 100$\psi h^2$, 100$\psi h^2$, 0, 0, 0, 0]，遵循DeepSORT。在CUDA实现中，我们为 $u$-和 $v$-相关的计算分别使用两个线程。一个块拥有32个线程，并且块的数量设置为 $\lceil n/16 \rceil$，其中 $n$ 是被跟踪对象的数量。

## 4.2 Fast
### 存储
在之前的研究中（Lu et al., 2020; Peng et al., 2020; Zhou et al., 2020; Wu et al., 2021; Zhang et al., 2022），轨迹通常表示为实例并通过列表存储，如图7b所示。由于程序不支持这些实例的并行访问，因此对每个轨迹的更新或访问操作在时间复杂度上为O(n)。如图7a所示，受奥卡姆剃刀原则的指导，我们放弃实例并创造性地提出使用GPU 2D数组来存储轨迹。在功能上，这两种存储可以执行完全相同的功能，如修改某些信息或添加/删除某些轨迹；在效率上，由于CUDA加速，可以以O(1)的时间复杂度高效地对所有轨迹执行并行更新或访问操作。在Fast中，每个轨迹具有属性Box（u, v, w, h）、Score、ClassID、TrackID、State（Track、Lost或New之一）、EndFrame，以及与PKF相关的变量（$\hat{x}$、p和o）。

<div align=center>
   <img src="(https://img-blog.csdnimg.cn/direct/8412db9d75fc4405a83f95a361ffcc74.png" width="800" />
</div>![在这里插入图片描述])


### 成本矩阵
由于Fast保持最简洁的处理流程，并且在一次迭代中只执行一次关联操作，成本矩阵的质量对跟踪结果至关重要。我们将框的质量（分数）考虑进成本矩阵中，以自动确定关联的优先级。具体来说，对于一个包含N个元素的轨迹列表和一个包含M个元素的检测列表，其中每个元素都有一个带有相应分数S的框B，N×M成本矩阵C计算如下：

$$C_ {ij} = \text{IoU}(B_ i, B_ j) \times S_ i \times S_ j$$

其中i/ j表示输入轨迹/检测中的第i/ j个元素。通过这种计算，得分高轨迹和检测将首先被分配；得分低的最后被分配；剩余的轨迹和检测为中等优先级。从另一个角度来看，我们在一次关联中通过分数实现了级联关联的效果。此外，这种新成本矩阵还可以通过在计算IoU之前将所有框沿x轴移动类ID乘以输入图像宽度的距离来实现多目标和多类跟踪。在实现中，我们将成本矩阵的每个元素分配给一个CUDA核以提高计算效率。此外，根据在高度和宽度比率中获得的先验，我们提出了HIoU度量来替换原始IoU在我们的成本矩阵中，其计算如下：

$$\text{HIoU}(B_ T, B_ D) = \begin{cases} 
0, & \text{如果} \frac{\min(h_ T, h_ D)}{\max(h_ T, h_ D)} < \lambda, \\
\text{IoU}(B_ T, B_ D), & \text{其他情况}.
\end{cases}$$

HIoU接收一个检测框BD和一个轨迹框BT，并在它们的高度比（hD和hT）大于或等于高度比率阈值λ时计算它们之间的IoU。否则，HIoU的结果为0。HIoU可以在行人或交通场景中使用，以进一步提高性能。


### 分配
为了使跟踪器能够完全由GPU加速，我们首先实现了拍卖算法（Auction Algorithm）来解决非对称分配问题。朴素的拍卖算法模拟了拍卖过程，用于解决经典对称分配问题，其中包含n个人和n个对象，我们需要一对一地进行匹配。对于匹配第i个人与第j个对象，有一个好处 $a_ {ij}$（属于一个n×n的成本矩阵），我们希望将人分配给对象，以最大化总好处。附录A详细描述了朴素拍卖算法的计算和实现。虽然成本矩阵的形状大多数时候是一个任意的（n×m）矩阵，但当n小于或等于m时，我们应用朴素拍卖算法来匹配轨迹和检测；当n大于m时，我们首先将成本矩阵转置（从n×m转换为m×n），然后应用朴素拍卖算法，同时结果需要映射回原始成本矩阵。

## 架构
沿着简洁和通用的跟踪器设计理念，Fast只在一个迭代过程中需要带有分数和类别ID的边界框来执行单一关联，从而允许高通用性和效率。Fast的输入是视频序列V和一个检测器Det(·)。最大丢失阈值τ和跟踪分数阈值ϵ（默认为0.7）也被设置。Fast的输出是视频的轨迹T，每个轨迹具有Box、Score、ClassID、TrackID、State（Track、Lost或New之一）和EndFrame等属性。如算法3所示的Fast的伪代码，对于视频V中的每个帧ft，Fast首先通过检测器Det(·)获得包括Box、Score和ClassID的检测Dt。然后计算轨迹T的运动估计（PKF的预测阶段）。之后，通过由它们生成的成本矩阵将检测Dt和轨迹T进行关联，Fast获得四组：匹配的检测Dm、匹配的轨迹Tm、未匹配的检测Du和未匹配的轨迹Tu。Dm中的检测将更新到Tm中的相应轨迹（9到10行），其中将执行PKF的更新阶段，轨迹的状态将设置为Track，并且结束帧将设置为当前帧ID fid。然后，如果Tu中的轨迹的EndFrame与fid之间的差异大于或等于τ或其状态为New，则将其移除，否则保留并将其状态设置为Lost（12到18行）。接下来，如果Du中的检测的分数大于或等于ϵ，则将其添加到T中（20到24行）。Init(·)包括将状态初始化为New，EndFrame初始化为fid，以及初始化PKF。每个帧的输出是新的轨迹T，其中Lost状态的轨迹不允许输出。


# 5 实验

## 5.1 设置
### 数据集
我们在上述MOT基准测试中评估Fast，包括MOT17、MOT20、KITTI和DanceTrack，这些基准测试涵盖了一般跟踪场景，如行人和车辆的跟踪。MOT17和MOT20主要关注行人跟踪，其中大多数运动是低速的。然而，与MOT17相比，MOT20的场景更加拥挤（平均每帧139个对象对比33个）。KITTI专注于交通跟踪，跟踪高速汽车和行人。DanceTrack是最近提出的一个基准测试，用于跟踪舞台上的舞者。在DanceTrack中，舞者表现出高度非线性的运动，外观相似，同时发生严重的遮挡和频繁的交叉。对于消融数据集，我们遵循先前的工作，并使用MOT17-val和DanceTrack验证集来验证我们提出的模块的有效性，如非均匀公式或成本矩阵。

### 指标
我们使用HOTA、IDF1和MOTA作为主要指标来评估跟踪性能的各个方面。HOTA是一个最近提出的指标，它明确平衡了准确检测、关联和定位的影响。IDF1评估身份保持能力，更注重关联性能。MOTA基于FP（误报）、FN（漏报）和ID切换计算。鉴于FP和FN的数量大于ID切换，MOTA更注重检测性能。此外，我们还报告了其他指标，如DetA（检测准确度）或AssA（关联准确度），以及原始统计数据，如ID切换（IDs）或片段（Frag）。

### 实现
所有实验都在一台装备有GTX 1080Ti GPU和i5-9500 CPU的PC上进行。Fast使用CuPy实现，CuPy是一个强大的基于CUDA的库，用于在NVIDIA GPU上进行快速矩阵运算，提供与NumPy几乎相同的API，并支持加载用C/C++编写的原始CUDA内核函数。我们的存储方法使用了CuPy提供的2D数组；成本矩阵、PKF和拍卖算法是用CUDA C/C++实现的，并通过CuPy调用。为了公平比较，我们直接使用了FastTrack中相同的检测器。对于MOT17、MOT20和DanceTrack，我们使用了ByteTrack中公开可用的YOLOX检测器权重；对于KITTI，我们使用了PermaTrack公开提供的检测结果，遵循OCSORT。

## 5.2 消融研究
所有消融研究都在MOT17-val和DanceTrack-val上进行，使用四个指标来评估性能：HOTA（H↑）、MOTA（M↑）、IDF1（I↑）和IDs（I↓）。

### 5.2.1 关联
**成本矩阵**
表2显示了在Fast中使用不同成本矩阵策略的实验结果。“Baseline”表示在BYTE中使用的基于分数的级联关联策略的结果。IoU、IoUD和IoUDT的效果在两个数据集的六个指标上都是递增的。与“Baseline”相比，IoUDT在所有指标上都有更好的性能，尽管使用了更简洁的分配策略。

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/56fce32136bd42a283e91f64bd9d2797.png" width="800" />
</div>


**HIoU**
如第3.2节所讨论的，与MOT17中的行人相比，DanceTrack中的舞者运动范围更广，因此不具有高度不变性先验。表3中不同高度比率阈值λ下的HIoUDT的实验结果也反映了这一点。在MOT17-val中，使用0.8阈值的HIoU可以提高HOTA和IDF1，因为它排除了潜在的错误分配；DanceTrack-val不符合该先验，因此应用HIoU导致所有指标下降。在后续的消融研究中，我们在MOT17-val中使用0.8阈值的HIoUDT；在DanceTrack-val中使用IoUDT。

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/05f1d83826004603aaa9d92b1ea22a11.png" width="800" />
</div>

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/1b2e466fdaf64d5da7d6df1e5eaf4a25.png" width="800" />
</div>

### 5.2.2 平行卡尔曼滤波器
**状态估计**
表5显示了不同状态的KF作为Fast的运动估计模块的实验结果。这里我们使用了具有不同状态的原始KF。uvγ h表示原始的八元组状态；uv表示我们提出的四元组状态。当从状态估计中移除γ和h时，Fast在所有指标上都表现出更好的性能，这也与第2.2节中的先前分析一致，即γ和h的均匀建模是不合理的，它们应该从KF的状态估计中移除。

**ξ阈值因子**

ξ用于区分低速物体和高速物体，如表6所示，具有最佳ξ值的Fast在两个数据集的HOTA和IDF1指标上的表现优于“基线”。由于不同类型场景的图像分辨率、物体大小和帧率的多样性，ξ的值需要具体设置。从表6的实验中可以看出，ξ的值大致在0.05到0.09之间。经验上，我们建议ξ的默认值为0.05，当跟踪场景中物体的总体运动更快或帧率较低时，可以适当增加到0.07或0.08以获得更好的跟踪结果。

**线性平滑权重ω**的引入对于减少物体运动中产生的噪声至关重要，因此，在表7中，具有最佳ω值的Fast在两个数据集的HOTA和IDF1指标上的表现优于“基线”。由于不同类型场景中的噪声不同，ω的值也需要具体设置。从表7的实验中可以看出，ω的值大致在0.85到0.70之间。经验上，我们建议ω的默认值为0.85，当跟踪场景中的物体运动（如舞台场景）高度非线性时，可以适当降低到0.70以获得更好的跟踪结果。

减速策略表8展示了我们减速策略的实验结果。对于MOT17-val，由于样本量小且其中的遮挡问题不严重，与“基线”相比，四个指标的改进很小。对于DanceTrack-val，结合足够的数据样本和严重的遮挡问题，我们的策略在HOTA和IDF1上比“基线”提高了1%。此外，立即停止丢失的对象与“基线”相比，在两个数据集中都没有显著优势。

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/ccdec6097e534767bb679c6cc2163e3d.png" width="800" />
</div>

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/7ec6c89535a14a46a8637e51d700dd59.png" width="800" />
</div>

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/f50f923f4b1a40fca2cbadb43a9cf464.png" width="800" />
</div>

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/23abac3f862a415f988372289cbc12de.png" width="800" />
</div>



### 5.2.3 与其他跟踪器的比较
表9展示了不同基于运动的跟踪器的实验结果。Fast在两个数据集上的所有指标上都优于排名第二的跟踪器1-2%。由于PKF能够模拟非均匀运动，Fast在DanceTrack-val数据集上的HOTA得分比排名第二的OCSORT高3.4%，在IDF1上高3.8%，同时保持了几乎相同的ID切换次数。

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/b4dbd07727354274917430f51c108e02.png" width="800" />
</div>

### 5.2.4 模块效率
如图8所示，我们比较了我们提出的模块与相应的基于CPU的基线的时间消耗。为了研究每个模块的最大计算效率，我们定义了一个极端情况，将轨迹数设置为1000。相反，我们将典型情况定义为将轨迹数设置为200，作为现实大规模对象跟踪情况下计算效率的代表。

**存储**
如图8a所示，我们比较了我们的GPU 2D数组存储方法与使用实例列表的基线方法的计算效率。平均时间消耗指的是更改所有n个轨迹的状态属性从Lost到Track所需的时间。我们的方法和基线方法的时间复杂度分别为O(1)和O(n)。在典型情况下，我们的方法比基线方法快3.6倍，而在极端情况下，快14倍。

**成本矩阵**
图8b比较了我们提出的代价矩阵方法（包括HIoU）与基线方法（cython_ box7）的计算效率。平均时间消耗表示创建一个n×n代价矩阵所需的时间。我们的方法的时间复杂度为O(1)，而基线方法的时间复杂度为O(n^2)。我们的方法在典型情况下比基线方法快6.2倍，在极端情况下快51倍。
**分配**
图8c展示了我们实现的拍卖算法与基线方法（LAPJV）的计算效率。平均时间消耗是解决一个n×n随机矩阵所需的时间，矩阵中的所有值在0到1之间。LAPJV的理论时间复杂度为O(n^3)，而我们方法的复杂度为O(n)，斜率较低。由于CPU和GPU的架构差异，GPU上启动内核函数需要额外的时间。当轨迹数少于300时，这种额外的时间成本掩盖了我们GPU方法的计算优势。然而，随着数据规模的增加，GPU的并行计算能力使得这种时间成本变得越来越不重要。因此，当轨迹数超过300时，我们GPU方法的处理速度超过了CPU方法。在典型情况下，我们的方法与基线几乎相同，但在极端情况下快4倍。

**卡尔曼滤波器**
图8d比较了我们的PKF与基线KF的计算效率。平均时间消耗是完成所有n个轨迹的预测-更新循环所需的时间。我们的方法和基线方法的时间复杂度分别为O(1)和O(n)。在典型情况下，我们的方法比基线快60倍，在极端情况下快306倍。此外，我们的PKF可以同时处理1000万个对象，每次迭代的平均时间为0.2毫秒，充分利用了GTX 1080Ti 12G视频内存，而原始KF处理相同数量的对象每次迭代需要大约600秒。

**讨论**
从上述分析中可以清楚地看出，传统基于CPU的跟踪器中每个关键模块的时间消耗，特别是卡尔曼滤波器，随着输入规模的增加而增加。这种增加对大规模对象跟踪的计算效率和MOT系统的稳定性产生了负面影响，导致处理速度随着输入规模的波动而波动。相比之下，我们提出的模块成功地将计算效率与输入规模分开。这种分离导致了一种新的基于GPU的跟踪器范式，它可以有效地管理大规模对象跟踪，同时保持MOT系统的稳定性。

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/fe5df92e3fe94c4b924cce9bbd45cf24.png" width="800" />
</div>


## 5.3 基准测试结果
我们分别报告了Fast在四个基准测试中的性能，并且Fast在每个基准测试上的可视化结果如图9所示。

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/28eb7b2d19a84e258d4accbfc8b1db69.png" width="800" />
</div>

### 5.3.1 DanceTrack
我们在表10中报告了DanceTrack测试集的结果，以评估Fast在具有挑战性的非均匀运动下的性能。测试期间超参数的设置与DanceTrack-val相同，即ξ为0.07，ω为0.7，并且在成本矩阵中不使用HIoU。我们提出的非均匀公式和减速策略成功地模拟了舞台场景中舞者的多样化非均匀运动，因此Fast在HOTA、MOTA和IDF1上达到了新的最佳水平。使用相同的检测器（YOLOX），Fast在HOTA上比OCSORT高出1.7%，比BYTE高出10.1%。

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/ca56e540b3c047668475efa00708caed.png" width="800" />
</div>


### 5.3.2 KITTI
表11显示了在KITTI测试集上的比较结果。与MOT17-val中的行人场景相比，KITTI中的交通场景由于低帧率（10对30），从跟踪器的角度来看，需要同时跟踪高速汽车和行人。因此，我们将ξ适当设置为0.08以处理高速运动，ω仍然遵循0.85的默认设置，并且在成本矩阵中使用HIoU，其中λ设置为0.5，基于图4 KITTI Train Car的统计先验。遵循OCSORT，我们使用PermaTr的检测结果来跟踪汽车和行人。值得注意的是，Fast可以通过我们提出的代价矩阵同时跟踪行人和汽车。Fast在汽车和行人的HOTA和MOTA上超越了PermaTr和OCSORT，并将行人跟踪性能（HOTA）提高到了新的最佳水平，即55.10%。

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/9192a7419b3c4fb5b5dd1de114898cfd.png" width="800" />
</div>

### 5.3.3 MOT挑战
我们在表12和表13中报告了Fast在MOT17和MOT20测试集上的性能，使用与ByteTrack和OCSORT相同的检测器YOLOX。遵循MOT17-val的设置，ξ默认为0.05，ω在MOT17和MOT20中均为0.85。在MOT17和MOT20上都使用了HIoU，并且λ设置为0.8。尽管接收到相同的检测结果，OCSORT首先丢弃了低分检测结果然后再开始跟踪，遵循SORT的做法，而Fast则利用分数优先级自动确定我们提出的代价矩阵中的关联优先级，这允许Fast跟踪更多低分对象，因此在MOTA上比OCSORT高出2.5%和1.8%。同时，Fast也在MOT17上达到了最高的HOTA和IDF1，在MOT20上则具有竞争性的HOTA。值得注意的是，在MOT20上，Fast通过其革命性的GPU范式获得了显著的效率提升，即比OCSORT快7倍。

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/8e8bc221255b47fcb9797b0d621904f8.png" width="800" />
</div>

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/e82cf762c9b9424cab3c64f7a23b8087.png" width="800" />
</div>

### 5.3.4 效率
图2展示了不同基于运动的跟踪器在四个基准测试上的平均处理时间。比较是在一台装有NVIDIA GTX 1080Ti和Intel Core i5-9500的单台PC上进行的。跟踪器在四个测试集上处理的平均对象数分别为6（KITTI）、8（DanceTrack）、33（MOT17）和139（MOT20）。如第5.2.4节所讨论的，我们新范式Fast的计算效率与输入规模无关，所有四个基准测试的平均时间消耗为4毫秒。当输入规模较小时（例如KITTI上的6个），额外的内核函数启动时间抵消了Fast的计算优势，导致Fast比其他基于CPU的跟踪器花费更多时间（4毫秒对1毫秒）。随着输入规模的增加，基于CPU的跟踪器的时间消耗迅速上升，而Fast的时间消耗保持恒定在4毫秒。例如，在MOT20上，Fast每帧保持在4毫秒，而OCSORT和BYTE分别需要30毫秒和20毫秒。即使在嵌入式CUDA设备Jetson AGX Xavier上，Fast在MOT20上的平均时间消耗仅为24毫秒，而OCSORT和BYTE分别需要231毫秒和67毫秒。为了进一步展示Fast在极端情况下的效率，我们在表14中比较了四种方法在不同规模的MOT20上的时间消耗。我们通过在MOT20测试集上复制每帧的检测结果N次来评估跟踪器在大规模对象跟踪场景中的效率。具体来说，我们将第i个复制结果的x坐标向右移动i×W像素（W为帧宽度），同时保持y坐标不变，从而将每帧的对象数量增加N倍。这种模拟在现实世界场景中是合理的，因为虽然单个视频流可能不会每帧包含1000个轨迹，但在现实场景中通常需要同时合并和跟踪多个流。表14表明，Fast在大规模对象跟踪场景中比其他跟踪器具有显著优势。例如，当N等于7时，Fast每帧处理时间为29毫秒，平均每帧973个对象，而OCSORT和BYTE分别需要241毫秒和161毫秒。

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/f4be205c5c51492dba8dc1a2737c1754.png" width="800" />
</div>

<div align=center>
   <img src="https://img-blog.csdnimg.cn/direct/055bc7fe79be42489e694ef6593889d7.png" width="800" />
</div>

## 6 结论
在本文中，我们提出了并行卡尔曼滤波器（Parallel Kalman Filter, PKF），通过所提出的非均匀公式模拟非均匀运动，并通过所提出的并行计算方法在大规模目标跟踪场景中实现了O(1)的时间复杂度。此外，基于PKF，我们提出了Fast，这是第一个完全基于GPU的跟踪器范式，大大改进了大规模目标跟踪的跟踪效率；以及FastTrack，由Fast和通用检测器组成的MOT系统，允许高效率和通用性。在Fast中，我们引入了创新的基于GPU的跟踪模块，如高效的GPU 2D数组数据结构、新的代价矩阵、一种称为HIoU的新关联度量，以及拍卖算法。进行的实验表明，PKF具有高度的计算效率，并且与输入规模无关，而Fast中的其他模块与基于CPU的基线相比也具有很高的效率。FastTrack在四个公共基准测试上展示了最先进的性能，并在MOT20的大规模跟踪场景中达到了最高速度。

# 声明
本文内容为论文学习收获分享，受限于知识能力，本文对原文的理解可能存在偏差，最终内容以原论文为准备。  
本文信息旨在传播和交流学术，其内容由作者负责，不代表本号观点。文中内容如涉及作品文字。图片等内容、版权和其他问题，请及时与我们联系，我们将在第一时间删文处理。

# 声明
本文内容为论文学习收获分享，受限于知识能力，本文对原文的理解可能存在偏差，最终内容以原论文为准备。  
本文信息旨在传播和交流学术，其内容由作者负责，不代表本号观点。文中内容如涉及作品文字。图片等内容、版权和其他问题，请及时与我们联系，我们将在第一时间删文处理。
